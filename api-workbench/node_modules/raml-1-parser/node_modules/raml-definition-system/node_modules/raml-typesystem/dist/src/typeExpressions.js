"use strict";
var typeExpression = require("./typeExpressionParser");
var ts = require("./typesystem");
var restrictions_1 = require("./restrictions");
function parseToType(val, t, contentProvider) {
    if (contentProvider === void 0) { contentProvider = null; }
    try {
        var q = val.trim();
        var json = q.charAt(0) == '{';
        if (json || q.charAt(0) == '<') {
            return new ts.ExternalType("", q, json, contentProvider);
        }
        var node = typeExpression.parse(val);
        var result = parseNode(node, t);
        return result;
    }
    catch (e) {
        return ts.derive(val, [ts.UNKNOWN]);
    }
}
exports.parseToType = parseToType;
function wrapArray(a, result) {
    while (a > 0) {
        var nt = ts.derive("", [ts.ARRAY]);
        nt.addMeta(new restrictions_1.ComponentShouldBeOfType(result));
        result = nt;
        a--;
    }
    return result;
}
function parseNode(node, t) {
    if (node.type == "union") {
        var ut = node;
        return ts.union("", [parseNode(ut.first, t), parseNode(ut.rest, t)]);
    }
    else if (node.type == "parens") {
        var ps = node;
        var rs = parseNode(ps.expr, t);
        return wrapArray(ps.arr, rs);
    }
    else {
        var lit = node;
        var result = t.get(lit.value);
        if (!result) {
            result = ts.derive(lit.value, [ts.UNKNOWN]);
        }
        var a = lit.arr;
        return wrapArray(a, result);
    }
}
function storeToString(t) {
    if (t.isSubTypeOf(ts.ARRAY)) {
        var cm = t.oneMeta(restrictions_1.ComponentShouldBeOfType);
        if (cm) {
            if (cm.value().isUnion()) {
                return "(" + storeToString(cm.value()) + ")" + "[]";
            }
            else
                return storeToString(cm.value()) + "[]";
        }
        return "array";
    }
    if (t instanceof ts.UnionType) {
        var ut = t;
        return ut.options().map(function (x) { return storeToString(x); }).join(" | ");
    }
    if (t.isAnonymous()) {
        if (t.isEmpty()) {
            return t.superTypes().map(function (x) { return storeToString(x); }).join(" , ");
        }
    }
    return t.name();
}
exports.storeToString = storeToString;
//# sourceMappingURL=typeExpressions.js.map