/**
 * <p>See <a href="http://raml.org">http://raml.org</a> for more information about RAML.</p>
 *
 * <p>This parser is at a beta state of development, as part of the API Workbench development cycle (<a href="http://apiworkbench.com">http://apiworkbench.com</a>).</p>
 *
 * <p><a href="https://github.com/raml-org/raml-js-parser-2/blob/master/documentation/GettingStarted.md">Getting Started Guide</a> describes the first steps with the parser.</p>
 *
 * <h2>Installation</h2>
 *
 * <pre><code>git clone https://github.com/raml-org/raml-js-parser-2
 *
 * cd raml-js-parser-2
 *
 * npm install
 *
 * node test/test.js  //here you should observe JSON representation of XKCD API in your console
 *
 * node test/testAsync.js  //same as above but in asynchronous mode
 * </code></pre>
 *
 * <h2>Usage</h2>
 *
 * <ul>
 * <li>For parser usage example refer to <code>test/test.js</code></li>
 * <li>For asynchrounous usage example refer to <code>test/testAsync.js</code></li>
 * </ul>
 **/
import hl = require("../../raml1/highLevelAST");
import core = require("../../raml1/wrapped-ast/parserCore");
import coreApi = require("../../raml1/wrapped-ast/parserCoreApi");
import pApi = require("./raml10parserapi");
import Api = pApi.Api;
import LibraryBase = pApi.LibraryBase;
import RAMLLanguageElement = pApi.RAMLLanguageElement;
import MarkdownString = pApi.MarkdownString;
import StringType = pApi.StringType;
import ValueType = pApi.ValueType;
import AnyType = pApi.AnyType;
import NumberType = pApi.NumberType;
import BooleanType = pApi.BooleanType;
import Reference = pApi.Reference;
import TypeInstance = pApi.TypeInstance;
import AnnotationRef = pApi.AnnotationRef;
import AnnotationTypeDeclaration = pApi.AnnotationTypeDeclaration;
import TypeDeclaration = pApi.TypeDeclaration;
import ModelLocation = pApi.ModelLocation;
import LocationKind = pApi.LocationKind;
import ExampleSpec = pApi.ExampleSpec;
import ArrayTypeDeclaration = pApi.ArrayTypeDeclaration;
import ArrayAnnotationTypeDeclaration = pApi.ArrayAnnotationTypeDeclaration;
import AnnotationTarget = pApi.AnnotationTarget;
import UnionTypeDeclaration = pApi.UnionTypeDeclaration;
import UnionAnnotationTypeDeclaration = pApi.UnionAnnotationTypeDeclaration;
import ObjectTypeDeclaration = pApi.ObjectTypeDeclaration;
import ObjectAnnotationTypeDeclaration = pApi.ObjectAnnotationTypeDeclaration;
import StringTypeDeclaration = pApi.StringTypeDeclaration;
import StringAnnotationTypeDeclaration = pApi.StringAnnotationTypeDeclaration;
import BooleanTypeDeclaration = pApi.BooleanTypeDeclaration;
import BooleanAnnotationTypeDeclaration = pApi.BooleanAnnotationTypeDeclaration;
import NumberTypeDeclaration = pApi.NumberTypeDeclaration;
import IntegerTypeDeclaration = pApi.IntegerTypeDeclaration;
import NumberAnnotationTypeDeclaration = pApi.NumberAnnotationTypeDeclaration;
import DateTypeDeclaration = pApi.DateTypeDeclaration;
import DateTypeAnnotationDeclaration = pApi.DateTypeAnnotationDeclaration;
import FileTypeDeclaration = pApi.FileTypeDeclaration;
import ContentType = pApi.ContentType;
import SecuritySchemeRef = pApi.SecuritySchemeRef;
import AbstractSecurityScheme = pApi.AbstractSecurityScheme;
import SecuritySchemePart = pApi.SecuritySchemePart;
import MethodBase = pApi.MethodBase;
import HasNormalParameters = pApi.HasNormalParameters;
import Response = pApi.Response;
import StatusCodeString = pApi.StatusCodeString;
import TraitRef = pApi.TraitRef;
import Trait = pApi.Trait;
import Library = pApi.Library;
import Method = pApi.Method;
import SecuritySchemeSettings = pApi.SecuritySchemeSettings;
import OAuth1SecuritySchemeSettings = pApi.OAuth1SecuritySchemeSettings;
import FixedUriString = pApi.FixedUriString;
import OAuth2SecuritySchemeSettings = pApi.OAuth2SecuritySchemeSettings;
import PassThroughSecuritySchemeSettings = pApi.PassThroughSecuritySchemeSettings;
import OAuth2SecurityScheme = pApi.OAuth2SecurityScheme;
import OAuth1SecurityScheme = pApi.OAuth1SecurityScheme;
import PassThroughSecurityScheme = pApi.PassThroughSecurityScheme;
import BasicSecurityScheme = pApi.BasicSecurityScheme;
import DigestSecurityScheme = pApi.DigestSecurityScheme;
import CustomSecurityScheme = pApi.CustomSecurityScheme;
import ResourceTypeRef = pApi.ResourceTypeRef;
import ResourceType = pApi.ResourceType;
import ResourceBase = pApi.ResourceBase;
import Resource = pApi.Resource;
import RelativeUriString = pApi.RelativeUriString;
import UriTemplate = pApi.UriTemplate;
import FullUriTemplateString = pApi.FullUriTemplateString;
import SchemaString = pApi.SchemaString;
import JSonSchemaString = pApi.JSonSchemaString;
import XMLSchemaString = pApi.XMLSchemaString;
import ExampleString = pApi.ExampleString;
import MimeType = pApi.MimeType;
import DocumentationItem = pApi.DocumentationItem;
import GlobalSchema = pApi.GlobalSchema;
import RAMLSimpleElement = pApi.RAMLSimpleElement;
import ImportDeclaration = pApi.ImportDeclaration;
import Overlay = pApi.Overlay;
import Extension = pApi.Extension;
export declare class RAMLLanguageElementImpl extends core.BasicNodeImpl implements RAMLLanguageElement {
    /**
     * The displayName attribute specifies the $self's display name. It is a friendly name used only for  display or documentation purposes. If displayName is not specified, it defaults to the element's key (the name of the property itself).
     **/
    displayName(): string;
    /**
     * @hidden
     * Set displayName value
     **/
    setDisplayName(param: string): this;
    /**
     * The description attribute describes the intended use or meaning of the $self. This value MAY be formatted using Markdown [MARKDOWN]
     **/
    description(): MarkdownString;
    /**
     * Most of RAML model elements may have attached annotations decribing additional meta data about this element
     **/
    annotations(): AnnotationRef[];
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
}
export declare class ValueTypeImpl extends core.AttributeNodeImpl implements ValueType {
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
    /**
     * @return JS representation of the node value
     **/
    value(): any;
}
export declare class AnyTypeImpl extends ValueTypeImpl implements AnyType {
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
}
export declare class NumberTypeImpl extends ValueTypeImpl implements NumberType {
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
    /**
     * @return Number representation of the node value
     **/
    value(): number;
}
export declare class BooleanTypeImpl extends ValueTypeImpl implements BooleanType {
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
    /**
     * @return Boolean representation of the node value
     **/
    value(): boolean;
}
export declare class ReferenceImpl extends core.AttributeNodeImpl implements Reference {
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
    /**
     * @return StructuredValue object representing the node value
     **/
    value(): hl.IStructuredValue;
    structuredValue(): TypeInstance;
    name(): string;
}
/**
 * Annotations allow you to attach information to your API
 **/
export declare class AnnotationRefImpl extends ReferenceImpl implements AnnotationRef {
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
    annotation(): AnnotationTypeDeclaration;
}
export declare class TypeDeclarationImpl extends RAMLLanguageElementImpl implements TypeDeclaration {
    protected nodeOrKey: hl.IHighLevelNode | string;
    protected setAsTopLevel: boolean;
    constructor(nodeOrKey: hl.IHighLevelNode | string, setAsTopLevel?: boolean);
    /**
     * name of the parameter
     **/
    name(): string;
    /**
     * @hidden
     * Set name value
     **/
    setName(param: string): this;
    /**
     * When extending from a type you can define new facets (which can then be set to concrete values by subtypes).
     **/
    facets(): TypeDeclaration[];
    /**
     * Alias for the equivalent "type" property, for compatibility with RAML 0.8. Deprecated - API definitions should use the "type" property, as the "schema" alias for that property name may be removed in a future RAML version. The "type" property allows for XML and JSON schemas.
     **/
    schema(): string[];
    /**
     * @hidden
     * Set schema value
     **/
    setSchema(param: string): this;
    /**
     * A base type which the current type extends, or more generally a type expression.
     **/
    "type"(): string[];
    /**
     * @hidden
     * Set type value
     **/
    setType(param: string): this;
    /**
     * Location of the parameter (can not be edited by user)
     **/
    location(): ModelLocation;
    /**
     * Kind of location
     **/
    locationKind(): LocationKind;
    /**
     * Provides default value for a property
     **/
    "default"(): any;
    /**
     * @hidden
     * Set default value
     **/
    setDefault(param: any): this;
    /**
     * An example of this type instance represented as string. This can be used, e.g., by documentation generators to generate sample values for an object of this type. Cannot be present if the examples property is present.
     * @hidden
     **/
    example_original(): string;
    /**
     * @hidden
     * Set example value
     **/
    setExample(param: string): this;
    /**
     * An object containing named examples of instances of this type. This can be used, e.g., by documentation generators to generate sample values for an object of this type. Cannot be present if the examples property is present.
     **/
    examples(): ExampleSpec[];
    /**
     * The repeat attribute specifies that the parameter can be repeated. If the parameter can be used multiple times, the repeat parameter value MUST be set to 'true'. Otherwise, the default value is 'false' and the parameter may not be repeated.
     **/
    repeat(): boolean;
    /**
     * @hidden
     * Set repeat value
     **/
    setRepeat(param: boolean): this;
    /**
     * Sets if property is optional or not
     **/
    required(): boolean;
    /**
     * @hidden
     * Set required value
     **/
    setRequired(param: boolean): this;
    /**
     * An alternate, human-friendly name for the type
     **/
    displayName(): string;
    /**
     * @hidden
     * Set displayName value
     **/
    setDisplayName(param: string): this;
    /**
     * A longer, human-friendly description of the type
     **/
    description(): MarkdownString;
    /**
     * Most of RAML model elements may have attached annotations decribing additional meta data about this element
     **/
    annotations(): AnnotationRef[];
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
    /**
     * Runtime representation of type represented by this AST node
     **/
    runtimeType(): hl.ITypeDefinition;
    /**
     * validate an instance against type
     **/
    validateInstance(value: any): string[];
    /**
     * An example of this type instance represented as string. This can be used, e.g., by documentation generators to generate sample values for an object of this type. Cannot be present if the examples property is present.
     **/
    example(): string;
    structuredExample(): TypeInstance;
    fixedFacets(): TypeInstance;
}
export declare class ModelLocationImpl implements ModelLocation {
    protected attr: hl.IAttribute;
    constructor(attr: hl.IAttribute);
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
}
export declare class LocationKindImpl implements LocationKind {
    protected attr: hl.IAttribute;
    constructor(attr: hl.IAttribute);
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
}
export declare class ExampleSpecImpl extends RAMLLanguageElementImpl implements ExampleSpec {
    protected nodeOrKey: hl.IHighLevelNode | string;
    protected setAsTopLevel: boolean;
    constructor(nodeOrKey: hl.IHighLevelNode | string, setAsTopLevel?: boolean);
    /**
     * String representation of example
     * @hidden
     **/
    content_original(): string;
    /**
     * @hidden
     * Set content value
     **/
    setContent(param: string): this;
    /**
     * By default, examples are validated against any type declaration. Set this to false to allow examples that need not validate.
     **/
    strict(): boolean;
    /**
     * @hidden
     * Set strict value
     **/
    setStrict(param: boolean): this;
    /**
     * Example identifier, if specified
     **/
    name(): string;
    /**
     * @hidden
     * Set name value
     **/
    setName(param: string): this;
    /**
     * An alternate, human-friendly name for the example
     **/
    displayName(): string;
    /**
     * @hidden
     * Set displayName value
     **/
    setDisplayName(param: string): this;
    /**
     * A longer, human-friendly description of the example
     **/
    description(): MarkdownString;
    /**
     * Most of RAML model elements may have attached annotations decribing additional meta data about this element
     **/
    annotations(): AnnotationRef[];
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
    /**
     * String representation of example
     **/
    content(): string;
    structuredContent(): TypeInstance;
}
export declare class ArrayTypeDeclarationImpl extends TypeDeclarationImpl implements ArrayTypeDeclaration {
    protected nodeOrKey: hl.IHighLevelNode | string;
    protected setAsTopLevel: boolean;
    constructor(nodeOrKey: hl.IHighLevelNode | string, setAsTopLevel?: boolean);
    /**
     * Should items in array be unique
     **/
    uniqueItems(): boolean;
    /**
     * @hidden
     * Set uniqueItems value
     **/
    setUniqueItems(param: boolean): this;
    /**
     * Array component type.
     **/
    items(): TypeDeclaration;
    /**
     * Minimum amount of items in array
     **/
    minItems(): number;
    /**
     * @hidden
     * Set minItems value
     **/
    setMinItems(param: number): this;
    /**
     * Maximum amount of items in array
     **/
    maxItems(): number;
    /**
     * @hidden
     * Set maxItems value
     **/
    setMaxItems(param: number): this;
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
}
export declare class ArrayAnnotationTypeDeclarationImpl extends ArrayTypeDeclarationImpl implements ArrayAnnotationTypeDeclaration {
    protected nodeOrKey: hl.IHighLevelNode | string;
    protected setAsTopLevel: boolean;
    constructor(nodeOrKey: hl.IHighLevelNode | string, setAsTopLevel?: boolean);
    /**
     * Restrictions on where annotations of this type can be applied. If this property is specified, annotations of this type may only be applied on a property corresponding to one of the target names specified as the value of this property.
     **/
    allowedTargets(): AnnotationTarget[];
    /**
     * Instructions on how and when to use this annotation in a RAML spec.
     **/
    usage(): string;
    /**
     * @hidden
     * Set usage value
     **/
    setUsage(param: string): this;
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
}
/**
 * Elements to which this Annotation can be applied (enum)
 **/
export declare class AnnotationTargetImpl extends ValueTypeImpl implements AnnotationTarget {
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
}
export declare class UnionTypeDeclarationImpl extends TypeDeclarationImpl implements UnionTypeDeclaration {
    protected nodeOrKey: hl.IHighLevelNode | string;
    protected setAsTopLevel: boolean;
    constructor(nodeOrKey: hl.IHighLevelNode | string, setAsTopLevel?: boolean);
    /**
     * Type property name to be used as a discriminator or boolean
     **/
    discriminator(): string;
    /**
     * @hidden
     * Set discriminator value
     **/
    setDiscriminator(param: string): this;
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
}
export declare class UnionAnnotationTypeDeclarationImpl extends UnionTypeDeclarationImpl implements UnionAnnotationTypeDeclaration {
    protected nodeOrKey: hl.IHighLevelNode | string;
    protected setAsTopLevel: boolean;
    constructor(nodeOrKey: hl.IHighLevelNode | string, setAsTopLevel?: boolean);
    /**
     * Restrictions on where annotations of this type can be applied. If this property is specified, annotations of this type may only be applied on a property corresponding to one of the target names specified as the value of this property.
     **/
    allowedTargets(): AnnotationTarget[];
    /**
     * Instructions on how and when to use this annotation in a RAML spec.
     **/
    usage(): string;
    /**
     * @hidden
     * Set usage value
     **/
    setUsage(param: string): this;
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
}
export declare class ObjectTypeDeclarationImpl extends TypeDeclarationImpl implements ObjectTypeDeclaration {
    protected nodeOrKey: hl.IHighLevelNode | string;
    protected setAsTopLevel: boolean;
    constructor(nodeOrKey: hl.IHighLevelNode | string, setAsTopLevel?: boolean);
    /**
     * The properties that instances of this type may or must have.
     **/
    properties(): TypeDeclaration[];
    /**
     * The minimum number of properties allowed for instances of this type.
     **/
    minProperties(): number;
    /**
     * @hidden
     * Set minProperties value
     **/
    setMinProperties(param: number): this;
    /**
     * The maximum number of properties allowed for instances of this type.
     **/
    maxProperties(): number;
    /**
     * @hidden
     * Set maxProperties value
     **/
    setMaxProperties(param: number): this;
    /**
     * JSON schema style syntax for declaring maps
     **/
    additionalProperties(): TypeDeclaration;
    /**
     * JSON schema style syntax for declaring key restricted maps
     **/
    patternProperties(): TypeDeclaration[];
    /**
     * Type property name to be used as discriminator, or boolean
     **/
    discriminator(): string;
    /**
     * @hidden
     * Set discriminator value
     **/
    setDiscriminator(param: string): this;
    /**
     * The value of discriminator for the type.
     **/
    discriminatorValue(): string;
    /**
     * @hidden
     * Set discriminatorValue value
     **/
    setDiscriminatorValue(param: string): this;
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
}
export declare class ObjectAnnotationTypeDeclarationImpl extends ObjectTypeDeclarationImpl implements ObjectAnnotationTypeDeclaration {
    protected nodeOrKey: hl.IHighLevelNode | string;
    protected setAsTopLevel: boolean;
    constructor(nodeOrKey: hl.IHighLevelNode | string, setAsTopLevel?: boolean);
    /**
     * Restrictions on where annotations of this type can be applied. If this property is specified, annotations of this type may only be applied on a property corresponding to one of the target names specified as the value of this property.
     **/
    allowedTargets(): AnnotationTarget[];
    /**
     * Instructions on how and when to use this annotation in a RAML spec.
     **/
    usage(): string;
    /**
     * @hidden
     * Set usage value
     **/
    setUsage(param: string): this;
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
}
/**
 * Value must be a string
 **/
export declare class StringTypeDeclarationImpl extends TypeDeclarationImpl implements StringTypeDeclaration {
    protected nodeOrKey: hl.IHighLevelNode | string;
    protected setAsTopLevel: boolean;
    constructor(nodeOrKey: hl.IHighLevelNode | string, setAsTopLevel?: boolean);
    /**
     * Regular expression that this string should path
     **/
    pattern(): string;
    /**
     * @hidden
     * Set pattern value
     **/
    setPattern(param: string): this;
    /**
     * Minimum length of the string
     **/
    minLength(): number;
    /**
     * @hidden
     * Set minLength value
     **/
    setMinLength(param: number): this;
    /**
     * Maximum length of the string
     **/
    maxLength(): number;
    /**
     * @hidden
     * Set maxLength value
     **/
    setMaxLength(param: number): this;
    /**
     * (Optional, applicable only for parameters of type string) The enum attribute provides an enumeration of the parameter's valid values. This MUST be an array. If the enum attribute is defined, API clients and servers MUST verify that a parameter's value matches a value in the enum array. If there is no matching value, the clients and servers MUST treat this as an error.
     **/
    enum(): string[];
    /**
     * @hidden
     * Set enum value
     **/
    setEnum(param: string): this;
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
}
export declare class StringAnnotationTypeDeclarationImpl extends StringTypeDeclarationImpl implements StringAnnotationTypeDeclaration {
    protected nodeOrKey: hl.IHighLevelNode | string;
    protected setAsTopLevel: boolean;
    constructor(nodeOrKey: hl.IHighLevelNode | string, setAsTopLevel?: boolean);
    /**
     * Restrictions on where annotations of this type can be applied. If this property is specified, annotations of this type may only be applied on a property corresponding to one of the target names specified as the value of this property.
     **/
    allowedTargets(): AnnotationTarget[];
    /**
     * Instructions on how and when to use this annotation in a RAML spec.
     **/
    usage(): string;
    /**
     * @hidden
     * Set usage value
     **/
    setUsage(param: string): this;
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
}
/**
 * Value must be a boolean
 **/
export declare class BooleanTypeDeclarationImpl extends TypeDeclarationImpl implements BooleanTypeDeclaration {
    protected nodeOrKey: hl.IHighLevelNode | string;
    protected setAsTopLevel: boolean;
    constructor(nodeOrKey: hl.IHighLevelNode | string, setAsTopLevel?: boolean);
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
}
export declare class BooleanAnnotationTypeDeclarationImpl extends BooleanTypeDeclarationImpl implements BooleanAnnotationTypeDeclaration {
    protected nodeOrKey: hl.IHighLevelNode | string;
    protected setAsTopLevel: boolean;
    constructor(nodeOrKey: hl.IHighLevelNode | string, setAsTopLevel?: boolean);
    /**
     * Restrictions on where annotations of this type can be applied. If this property is specified, annotations of this type may only be applied on a property corresponding to one of the target names specified as the value of this property.
     **/
    allowedTargets(): AnnotationTarget[];
    /**
     * Instructions on how and when to use this annotation in a RAML spec.
     **/
    usage(): string;
    /**
     * @hidden
     * Set usage value
     **/
    setUsage(param: string): this;
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
}
/**
 * Value MUST be a number. Indicate floating point numbers as defined by YAML.
 **/
export declare class NumberTypeDeclarationImpl extends TypeDeclarationImpl implements NumberTypeDeclaration {
    protected nodeOrKey: hl.IHighLevelNode | string;
    protected setAsTopLevel: boolean;
    constructor(nodeOrKey: hl.IHighLevelNode | string, setAsTopLevel?: boolean);
    /**
     * (Optional, applicable only for parameters of type number or integer) The minimum attribute specifies the parameter's minimum value.
     **/
    minimum(): number;
    /**
     * @hidden
     * Set minimum value
     **/
    setMinimum(param: number): this;
    /**
     * (Optional, applicable only for parameters of type number or integer) The maximum attribute specifies the parameter's maximum value.
     **/
    maximum(): number;
    /**
     * @hidden
     * Set maximum value
     **/
    setMaximum(param: number): this;
    /**
     * (Optional, applicable only for parameters of type string) The enum attribute provides an enumeration of the parameter's valid values. This MUST be an array. If the enum attribute is defined, API clients and servers MUST verify that a parameter's value matches a value in the enum array. If there is no matching value, the clients and servers MUST treat this as an error.
     **/
    enum(): string[];
    /**
     * @hidden
     * Set enum value
     **/
    setEnum(param: string): this;
    /**
     * Value format
     **/
    format(): string;
    /**
     * @hidden
     * Set format value
     **/
    setFormat(param: string): this;
    /**
     * A numeric instance is valid against "multipleOf" if the result of the division of the instance by this keyword's value is an integer.
     **/
    multipleOf(): number;
    /**
     * @hidden
     * Set multipleOf value
     **/
    setMultipleOf(param: number): this;
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
}
/**
 * Value MUST be a integer.
 **/
export declare class IntegerTypeDeclarationImpl extends NumberTypeDeclarationImpl implements IntegerTypeDeclaration {
    protected nodeOrKey: hl.IHighLevelNode | string;
    protected setAsTopLevel: boolean;
    constructor(nodeOrKey: hl.IHighLevelNode | string, setAsTopLevel?: boolean);
    /**
     * Value format
     **/
    format(): string;
    /**
     * @hidden
     * Set format value
     **/
    setFormat(param: string): this;
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
}
export declare class NumberAnnotationTypeDeclarationImpl extends NumberTypeDeclarationImpl implements NumberAnnotationTypeDeclaration {
    protected nodeOrKey: hl.IHighLevelNode | string;
    protected setAsTopLevel: boolean;
    constructor(nodeOrKey: hl.IHighLevelNode | string, setAsTopLevel?: boolean);
    /**
     * Restrictions on where annotations of this type can be applied. If this property is specified, annotations of this type may only be applied on a property corresponding to one of the target names specified as the value of this property.
     **/
    allowedTargets(): AnnotationTarget[];
    /**
     * Instructions on how and when to use this annotation in a RAML spec.
     **/
    usage(): string;
    /**
     * @hidden
     * Set usage value
     **/
    setUsage(param: string): this;
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
}
/**
 * Value MUST be a string representation of a date as defined in RFC2616 Section 3.3, or according to specified date format
 **/
export declare class DateTypeDeclarationImpl extends TypeDeclarationImpl implements DateTypeDeclaration {
    protected nodeOrKey: hl.IHighLevelNode | string;
    protected setAsTopLevel: boolean;
    constructor(nodeOrKey: hl.IHighLevelNode | string, setAsTopLevel?: boolean);
    format(): string;
    /**
     * @hidden
     * Set format value
     **/
    setFormat(param: string): this;
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
}
export declare class DateTypeAnnotationDeclarationImpl extends DateTypeDeclarationImpl implements DateTypeAnnotationDeclaration {
    protected nodeOrKey: hl.IHighLevelNode | string;
    protected setAsTopLevel: boolean;
    constructor(nodeOrKey: hl.IHighLevelNode | string, setAsTopLevel?: boolean);
    /**
     * Restrictions on where annotations of this type can be applied. If this property is specified, annotations of this type may only be applied on a property corresponding to one of the target names specified as the value of this property.
     **/
    allowedTargets(): AnnotationTarget[];
    /**
     * Instructions on how and when to use this annotation in a RAML spec.
     **/
    usage(): string;
    /**
     * @hidden
     * Set usage value
     **/
    setUsage(param: string): this;
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
}
/**
 * (Applicable only to Form properties) Value is a file. Client generators SHOULD use this type to handle file uploads correctly.
 **/
export declare class FileTypeDeclarationImpl extends TypeDeclarationImpl implements FileTypeDeclaration {
    protected nodeOrKey: hl.IHighLevelNode | string;
    protected setAsTopLevel: boolean;
    constructor(nodeOrKey: hl.IHighLevelNode | string, setAsTopLevel?: boolean);
    /**
     * It should also include a new property: fileTypes, which should be a list of valid content-type strings for the file. The file type * /* should be a valid value.
     **/
    fileTypes(): ContentType[];
    /**
     * The minLength attribute specifies the parameter value's minimum number of bytes.
     **/
    minLength(): number;
    /**
     * @hidden
     * Set minLength value
     **/
    setMinLength(param: number): this;
    /**
     * The maxLength attribute specifies the parameter value's maximum number of bytes.
     **/
    maxLength(): number;
    /**
     * @hidden
     * Set maxLength value
     **/
    setMaxLength(param: number): this;
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
}
export declare class StringTypeImpl extends ValueTypeImpl implements StringType {
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
    /**
     * @return String representation of the node value
     **/
    value(): string;
}
export declare class ContentTypeImpl extends StringTypeImpl implements ContentType {
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
}
export declare class AnnotationTypeDeclarationImpl extends TypeDeclarationImpl implements AnnotationTypeDeclaration {
    protected nodeOrKey: hl.IHighLevelNode | string;
    protected setAsTopLevel: boolean;
    constructor(nodeOrKey: hl.IHighLevelNode | string, setAsTopLevel?: boolean);
    /**
     * Restrictions on where annotations of this type can be applied. If this property is specified, annotations of this type may only be applied on a property corresponding to one of the target names specified as the value of this property.
     **/
    allowedTargets(): AnnotationTarget[];
    /**
     * Instructions on how and when to use this annotation in a RAML spec.
     **/
    usage(): string;
    /**
     * @hidden
     * Set usage value
     **/
    setUsage(param: string): this;
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
}
export declare class SecuritySchemeRefImpl extends ReferenceImpl implements SecuritySchemeRef {
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
    securitySchemeName(): string;
    securityScheme(): AbstractSecurityScheme;
}
/**
 * Declares globally referable security scheme definition
 **/
export declare class AbstractSecuritySchemeImpl extends RAMLLanguageElementImpl implements AbstractSecurityScheme {
    protected nodeOrKey: hl.IHighLevelNode | string;
    protected setAsTopLevel: boolean;
    constructor(nodeOrKey: hl.IHighLevelNode | string, setAsTopLevel?: boolean);
    /**
     * Name of the security scheme
     **/
    name(): string;
    /**
     * @hidden
     * Set name value
     **/
    setName(param: string): this;
    /**
     * The securitySchemes property MUST be used to specify an API's security mechanisms, including the required settings and the authentication methods that the API supports. one authentication method is allowed if the API supports them.
     **/
    "type"(): string;
    /**
     * @hidden
     * Set type value
     **/
    setType(param: string): this;
    /**
     * The description MAY be used to describe a securityScheme.
     **/
    description(): MarkdownString;
    /**
     * A description of the request components related to Security that are determined by the scheme: the headers, query parameters or responses. As a best practice, even for standard security schemes, API designers SHOULD describe these properties of security schemes. Including the security scheme description completes an API documentation.
     **/
    describedBy(): SecuritySchemePart;
    /**
     * The settings attribute MAY be used to provide security scheme-specific information. The required attributes vary depending on the type of security scheme is being declared. It describes the minimum set of properties which any processing application MUST provide and validate if it chooses to implement the security scheme. Processing applications MAY choose to recognize other properties for things such as token lifetime, preferred cryptographic algorithms, and more.
     **/
    settings(): SecuritySchemeSettings;
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
}
export declare class HasNormalParametersImpl extends RAMLLanguageElementImpl implements HasNormalParameters {
    protected nodeOrKey: hl.IHighLevelNode | string;
    protected setAsTopLevel: boolean;
    constructor(nodeOrKey: hl.IHighLevelNode | string, setAsTopLevel?: boolean);
    /**
     * An APIs resources MAY be filtered (to return a subset of results) or altered (such as transforming  a response body from JSON to XML format) by the use of query strings. If the resource or its method supports a query string, the query string MUST be defined by the queryParameters property
     **/
    queryParameters(): TypeDeclaration[];
    /**
     * Headers that allowed at this position
     **/
    headers(): TypeDeclaration[];
    /**
     * Specifies the query string needed by this method. Mutually exclusive with queryParameters.
     **/
    queryString(): TypeDeclaration;
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
}
export declare class MethodBaseImpl extends HasNormalParametersImpl implements MethodBase {
    protected nodeOrKey: hl.IHighLevelNode | string;
    protected setAsTopLevel: boolean;
    constructor(nodeOrKey: hl.IHighLevelNode | string, setAsTopLevel?: boolean);
    /**
     * Information about the expected responses to a request
     **/
    responses(): Response[];
    /**
     * Some method verbs expect the resource to be sent as a request body. For example, to create a resource, the request must include the details of the resource to create. Resources CAN have alternate representations. For example, an API might support both JSON and XML representations. A method's body is defined in the body property as a hashmap, in which the key MUST be a valid media type.
     **/
    body(): TypeDeclaration[];
    /**
     * A method can override the protocols specified in the resource or at the API root, by employing this property.
     **/
    protocols(): string[];
    /**
     * @hidden
     * Set protocols value
     **/
    setProtocols(param: string): this;
    /**
     * Instantiation of applyed traits
     **/
    is(): TraitRef[];
    /**
     * securityScheme may also be applied to a resource by using the securedBy key, which is equivalent to applying the securityScheme to all methods that may be declared, explicitly or implicitly, by defining the resourceTypes or traits property for that resource. To indicate that the method may be called without applying any securityScheme, the method may be annotated with the null securityScheme.
     **/
    securedBy(): SecuritySchemeRef[];
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
}
export declare class ResponseImpl extends RAMLLanguageElementImpl implements Response {
    protected nodeOrKey: hl.IHighLevelNode | string;
    protected setAsTopLevel: boolean;
    constructor(nodeOrKey: hl.IHighLevelNode | string, setAsTopLevel?: boolean);
    /**
     * Responses MUST be a map of one or more HTTP status codes, where each status code itself is a map that describes that status code.
     **/
    code(): StatusCodeString;
    /**
     * Detailed information about any response headers returned by this method
     **/
    headers(): TypeDeclaration[];
    /**
     * The body of the response: a body declaration
     **/
    body(): TypeDeclaration[];
    /**
     * An alternate, human-friendly name for the response
     **/
    displayName(): string;
    /**
     * @hidden
     * Set displayName value
     **/
    setDisplayName(param: string): this;
    /**
     * A longer, human-friendly description of the response
     **/
    description(): MarkdownString;
    /**
     * Most of RAML model elements may have attached annotations decribing additional meta data about this element
     **/
    annotations(): AnnotationRef[];
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
    /**
     * true for codes < 400 and false otherwise
     **/
    isOkRange(): boolean;
}
export declare class StatusCodeStringImpl extends StringTypeImpl implements StatusCodeString {
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
}
export declare class TraitRefImpl extends ReferenceImpl implements TraitRef {
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
    trait(): Trait;
}
export declare class TraitImpl extends MethodBaseImpl implements Trait {
    protected nodeOrKey: hl.IHighLevelNode | string;
    protected setAsTopLevel: boolean;
    constructor(nodeOrKey: hl.IHighLevelNode | string, setAsTopLevel?: boolean);
    /**
     * Name of the trait
     **/
    name(): string;
    /**
     * @hidden
     * Set name value
     **/
    setName(param: string): this;
    /**
     * Instructions on how and when the trait should be used.
     **/
    usage(): string;
    /**
     * @hidden
     * Set usage value
     **/
    setUsage(param: string): this;
    /**
     * You may import library locally here it contents is accessible only inside of this trait
     **/
    uses(): Library[];
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
    parametrizedProperties(): TypeInstance;
}
export declare class LibraryBaseImpl extends RAMLLanguageElementImpl implements LibraryBase {
    protected nodeOrKey: hl.IHighLevelNode | string;
    protected setAsTopLevel: boolean;
    constructor(nodeOrKey: hl.IHighLevelNode | string, setAsTopLevel?: boolean);
    /**
     * Alias for the equivalent "types" property, for compatibility with RAML 0.8. Deprecated - API definitions should use the "types" property, as the "schemas" alias for that property name may be removed in a future RAML version. The "types" property allows for XML and JSON schemas.
     **/
    schemas(): GlobalSchema[];
    /**
     * Declarations of (data) types for use within this API
     **/
    types(): TypeDeclaration[];
    /**
     * Declarations of traits for use within this API
     * @hidden
     **/
    traits_original(): Trait[];
    /**
     * Declarations of resource types for use within this API
     * @hidden
     **/
    resourceTypes_original(): ResourceType[];
    /**
     * Declarations of annotation types for use by annotations
     **/
    annotationTypes(): AnnotationTypeDeclaration[];
    /**
     * Declarations of security schemes for use within this API.
     **/
    securitySchemes(): AbstractSecurityScheme[];
    /**
     * Importing libraries
     **/
    uses(): Library[];
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
    /**
     * Declarations of traits for use within this API
     **/
    traits(): Trait[];
    /**
     * Retrieve all traits including those defined in libraries
     * @deprecated
     **/
    allTraits(): Trait[];
    /**
     * Declarations of resource types for use within this API
     **/
    resourceTypes(): ResourceType[];
    /**
     * Retrieve all resource types including those defined in libraries
     * @deprecated
     **/
    allResourceTypes(): ResourceType[];
}
export declare class LibraryImpl extends LibraryBaseImpl implements Library {
    protected nodeOrKey: hl.IHighLevelNode | string;
    protected setAsTopLevel: boolean;
    constructor(nodeOrKey: hl.IHighLevelNode | string, setAsTopLevel?: boolean);
    /**
     * contains description of why library exist
     **/
    usage(): string;
    /**
     * @hidden
     * Set usage value
     **/
    setUsage(param: string): this;
    /**
     * Namespace which the library is imported under
     **/
    name(): string;
    /**
     * @hidden
     * Set name value
     **/
    setName(param: string): this;
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
}
export declare class MethodImpl extends MethodBaseImpl implements Method {
    protected nodeOrKey: hl.IHighLevelNode | string;
    protected setAsTopLevel: boolean;
    constructor(nodeOrKey: hl.IHighLevelNode | string, setAsTopLevel?: boolean);
    /**
     * Method that can be called
     **/
    method(): string;
    /**
     * @hidden
     * Set method value
     **/
    setMethod(param: string): this;
    /**
     * An alternate, human-friendly name for the method (in the resource's context).
     **/
    displayName(): string;
    /**
     * @hidden
     * Set displayName value
     **/
    setDisplayName(param: string): this;
    /**
     * A longer, human-friendly description of the method (in the resource's context)
     **/
    description(): MarkdownString;
    /**
     * Specifies the query string needed by this method. Mutually exclusive with queryParameters.
     **/
    queryString(): TypeDeclaration;
    /**
     * Detailed information about any query parameters needed by this method. Mutually exclusive with queryString.
     **/
    queryParameters(): TypeDeclaration[];
    /**
     * Detailed information about any request headers needed by this method.
     **/
    headers(): TypeDeclaration[];
    /**
     * Some methods admit request bodies, which are described by this property.
     **/
    body(): TypeDeclaration[];
    /**
     * A list of the traits to apply to this method.
     **/
    is(): TraitRef[];
    /**
     * Most of RAML model elements may have attached annotations decribing additional meta data about this element
     **/
    annotations(): AnnotationRef[];
    /**
     * The security schemes that apply to this method
     **/
    securedBy(): SecuritySchemeRef[];
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
    /**
     * For methods of Resources returns parent resource. For methods of ResourceTypes returns null.
     **/
    parentResource(): Resource;
    /**
     * Api owning the resource as a sibling
     **/
    ownerApi(): Api;
    /**
     * For methods of Resources: `{parent Resource relative path} {methodName}`.
     * For methods of ResourceTypes: `{parent ResourceType name} {methodName}`.
     * For other methods throws Exception.
     **/
    methodId(): string;
    /**
     * Returns security schemes, resource or method is secured with. If no security schemes are set at resource or method level,
     * returns schemes defined with `securedBy` at API level.
     * @deprecated
     **/
    allSecuredBy(): SecuritySchemeRef[];
}
export declare class SecuritySchemePartImpl extends MethodBaseImpl implements SecuritySchemePart {
    protected nodeOrKey: hl.IHighLevelNode | string;
    protected setAsTopLevel: boolean;
    constructor(nodeOrKey: hl.IHighLevelNode | string, setAsTopLevel?: boolean);
    /**
     * Headers that allowed at this position
     **/
    headers(): TypeDeclaration[];
    /**
     * An APIs resources MAY be filtered (to return a subset of results) or altered (such as transforming  a response body from JSON to XML format) by the use of query strings. If the resource or its method supports a query string, the query string MUST be defined by the queryParameters property
     **/
    queryParameters(): TypeDeclaration[];
    /**
     * Specifies the query string, used by the scheme in order to authorize the request. Mutually exclusive with queryParameters.
     **/
    queryString(): TypeDeclaration;
    /**
     * Optional array of responses, describing the possible responses that could be sent.
     **/
    responses(): Response[];
    /**
     * Instantiation of applyed traits
     **/
    is(): TraitRef[];
    /**
     * securityScheme may also be applied to a resource by using the securedBy key, which is equivalent to applying the securityScheme to all methods that may be declared, explicitly or implicitly, by defining the resourceTypes or traits property for that resource. To indicate that the method may be called without applying any securityScheme, the method may be annotated with the null securityScheme.
     **/
    securedBy(): SecuritySchemeRef[];
    /**
     * An alternate, human-friendly name for the security scheme part
     **/
    displayName(): string;
    /**
     * @hidden
     * Set displayName value
     **/
    setDisplayName(param: string): this;
    /**
     * A longer, human-friendly description of the security scheme part
     **/
    description(): MarkdownString;
    /**
     * Annotations to be applied to this security scheme part. Annotations are any property whose key begins with "(" and ends with ")" and whose name (the part between the beginning and ending parentheses) is a declared annotation name.
     **/
    annotations(): AnnotationRef[];
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
}
export declare class SecuritySchemeSettingsImpl extends core.BasicNodeImpl implements SecuritySchemeSettings {
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
}
export declare class OAuth1SecuritySchemeSettingsImpl extends SecuritySchemeSettingsImpl implements OAuth1SecuritySchemeSettings {
    protected nodeOrKey: hl.IHighLevelNode | string;
    protected setAsTopLevel: boolean;
    constructor(nodeOrKey: hl.IHighLevelNode | string, setAsTopLevel?: boolean);
    /**
     * The URI of the Temporary Credential Request endpoint as defined in RFC5849 Section 2.1
     **/
    requestTokenUri(): FixedUriString;
    /**
     * The URI of the Resource Owner Authorization endpoint as defined in RFC5849 Section 2.2
     **/
    authorizationUri(): FixedUriString;
    /**
     * The URI of the Token Request endpoint as defined in RFC5849 Section 2.3
     **/
    tokenCredentialsUri(): FixedUriString;
    /**
     * List of the signature methods used by the server. Available methods: HMAC-SHA1, RSA-SHA1, PLAINTEXT
     **/
    signatures(): string[];
    /**
     * @hidden
     * Set signatures value
     **/
    setSignatures(param: string): this;
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
}
/**
 * This  type describes fixed uris
 **/
export declare class FixedUriStringImpl extends StringTypeImpl implements FixedUriString {
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
}
export declare class OAuth2SecuritySchemeSettingsImpl extends SecuritySchemeSettingsImpl implements OAuth2SecuritySchemeSettings {
    protected nodeOrKey: hl.IHighLevelNode | string;
    protected setAsTopLevel: boolean;
    constructor(nodeOrKey: hl.IHighLevelNode | string, setAsTopLevel?: boolean);
    /**
     * The URI of the Token Endpoint as defined in RFC6749 Section 3.2. Not required forby implicit grant type.
     **/
    accessTokenUri(): FixedUriString;
    /**
     * The URI of the Authorization Endpoint as defined in RFC6749 Section 3.1. Required forby authorization_code and implicit grant types.
     **/
    authorizationUri(): FixedUriString;
    /**
     * A list of the Authorization grants supported by the API as defined in RFC6749 Sections 4.1, 4.2, 4.3 and 4.4, can be any of: authorization_code, password, client_credentials, implicit, or refresh_token.
     **/
    authorizationGrants(): string[];
    /**
     * @hidden
     * Set authorizationGrants value
     **/
    setAuthorizationGrants(param: string): this;
    /**
     * A list of scopes supported by the security scheme as defined in RFC6749 Section 3.3
     **/
    scopes(): string[];
    /**
     * @hidden
     * Set scopes value
     **/
    setScopes(param: string): this;
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
}
export declare class PassThroughSecuritySchemeSettingsImpl extends SecuritySchemeSettingsImpl implements PassThroughSecuritySchemeSettings {
    protected nodeOrKey: hl.IHighLevelNode | string;
    protected setAsTopLevel: boolean;
    constructor(nodeOrKey: hl.IHighLevelNode | string, setAsTopLevel?: boolean);
    /**
     * Name of query parameter used to pass key
     **/
    queryParameterName(): string;
    /**
     * @hidden
     * Set queryParameterName value
     **/
    setQueryParameterName(param: string): this;
    /**
     * Name of header used to pass key
     **/
    headerName(): string;
    /**
     * @hidden
     * Set headerName value
     **/
    setHeaderName(param: string): this;
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
}
/**
 * Declares globally referable security scheme definition
 **/
export declare class OAuth2SecuritySchemeImpl extends AbstractSecuritySchemeImpl implements OAuth2SecurityScheme {
    protected nodeOrKey: hl.IHighLevelNode | string;
    protected setAsTopLevel: boolean;
    constructor(nodeOrKey: hl.IHighLevelNode | string, setAsTopLevel?: boolean);
    settings(): OAuth2SecuritySchemeSettings;
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
}
/**
 * Declares globally referable security scheme definition
 **/
export declare class OAuth1SecuritySchemeImpl extends AbstractSecuritySchemeImpl implements OAuth1SecurityScheme {
    protected nodeOrKey: hl.IHighLevelNode | string;
    protected setAsTopLevel: boolean;
    constructor(nodeOrKey: hl.IHighLevelNode | string, setAsTopLevel?: boolean);
    settings(): OAuth1SecuritySchemeSettings;
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
}
/**
 * Declares globally referable security scheme definition
 **/
export declare class PassThroughSecuritySchemeImpl extends AbstractSecuritySchemeImpl implements PassThroughSecurityScheme {
    protected nodeOrKey: hl.IHighLevelNode | string;
    protected setAsTopLevel: boolean;
    constructor(nodeOrKey: hl.IHighLevelNode | string, setAsTopLevel?: boolean);
    settings(): PassThroughSecuritySchemeSettings;
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
}
/**
 * Declares globally referable security scheme definition
 **/
export declare class BasicSecuritySchemeImpl extends AbstractSecuritySchemeImpl implements BasicSecurityScheme {
    protected nodeOrKey: hl.IHighLevelNode | string;
    protected setAsTopLevel: boolean;
    constructor(nodeOrKey: hl.IHighLevelNode | string, setAsTopLevel?: boolean);
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
}
/**
 * Declares globally referable security scheme definition
 **/
export declare class DigestSecuritySchemeImpl extends AbstractSecuritySchemeImpl implements DigestSecurityScheme {
    protected nodeOrKey: hl.IHighLevelNode | string;
    protected setAsTopLevel: boolean;
    constructor(nodeOrKey: hl.IHighLevelNode | string, setAsTopLevel?: boolean);
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
}
/**
 * Declares globally referable security scheme definition
 **/
export declare class CustomSecuritySchemeImpl extends AbstractSecuritySchemeImpl implements CustomSecurityScheme {
    protected nodeOrKey: hl.IHighLevelNode | string;
    protected setAsTopLevel: boolean;
    constructor(nodeOrKey: hl.IHighLevelNode | string, setAsTopLevel?: boolean);
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
}
export declare class ResourceTypeRefImpl extends ReferenceImpl implements ResourceTypeRef {
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
    resourceType(): ResourceType;
}
export declare class ResourceBaseImpl extends RAMLLanguageElementImpl implements ResourceBase {
    protected nodeOrKey: hl.IHighLevelNode | string;
    protected setAsTopLevel: boolean;
    constructor(nodeOrKey: hl.IHighLevelNode | string, setAsTopLevel?: boolean);
    /**
     * Methods that are part of this resource type definition
     **/
    methods(): Method[];
    /**
     * A list of the traits to apply to all methods declared (implicitly or explicitly) for this resource. Individual methods may override this declaration
     **/
    is(): TraitRef[];
    /**
     * The resource type which this resource inherits.
     **/
    "type"(): ResourceTypeRef;
    /**
     * The security schemes that apply to all methods declared (implicitly or explicitly) for this resource.
     **/
    securedBy(): SecuritySchemeRef[];
    /**
     * Detailed information about any URI parameters of this resource
     * @hidden
     **/
    uriParameters_original(): TypeDeclaration[];
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
    /**
     * Detailed information about any URI parameters of this resource
     **/
    uriParameters(): TypeDeclaration[];
    /**
     * Retrieve an ordered list of all uri parameters including those which are not described in the `uriParameters` node.
     * Consider a fragment of RAML specification:
     * ```yaml
     * /resource/{objectId}/{propertyId}:
     * uriParameters:
     * objectId:
     * ```
     * Here `propertyId` uri parameter is not described in the `uriParameters` node,
     * but it is among Resource.allUriParameters().
     * @deprecated
     **/
    allUriParameters(): TypeDeclaration[];
    /**
     * Returns security schemes, resource or method is secured with. If no security schemes are set at resource or method level,
     * returns schemes defined with `securedBy` at API level.
     * @deprecated
     **/
    allSecuredBy(): SecuritySchemeRef[];
}
export declare class ResourceImpl extends ResourceBaseImpl implements Resource {
    protected nodeOrKey: hl.IHighLevelNode | string;
    protected setAsTopLevel: boolean;
    constructor(nodeOrKey: hl.IHighLevelNode | string, setAsTopLevel?: boolean);
    /**
     * Relative URL of this resource from the parent resource
     **/
    relativeUri(): RelativeUriString;
    /**
     * A nested resource is identified as any property whose name begins with a slash ("/") and is therefore treated as a relative URI.
     **/
    resources(): Resource[];
    /**
     * An alternate, human-friendly name for the resource.
     **/
    displayName(): string;
    /**
     * @hidden
     * Set displayName value
     **/
    setDisplayName(param: string): this;
    /**
     * A longer, human-friendly description of the resource.
     **/
    description(): MarkdownString;
    /**
     * Most of RAML model elements may have attached annotations decribing additional meta data about this element
     **/
    annotations(): AnnotationRef[];
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
    /**
     * Path relative to API root
     **/
    completeRelativeUri(): string;
    /**
     * baseUri of owning Api concatenated with completeRelativeUri
     **/
    absoluteUri(): string;
    /**
     * Parent resource for non top level resources
     **/
    parentResource(): Resource;
    /**
     * Get child resource by its relative path
     **/
    childResource(relPath: string): Resource;
    /**
     * Get child method by its name
     **/
    childMethod(method: string): Method[];
    /**
     * Api owning the resource as a sibling
     **/
    ownerApi(): Api;
    /**
     * Retrieve an ordered list of all absolute uri parameters. Returns a union of `Api.baseUriParameters()`
     * for `Api` owning the `Resource` and `Resource.uriParameters()`.
     **/
    absoluteUriParameters(): TypeDeclaration[];
}
/**
 * This type currently serves both for absolute and relative urls
 **/
export declare class UriTemplateImpl extends StringTypeImpl implements UriTemplate {
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
}
/**
 * This  type describes absolute uri templates
 **/
export declare class FullUriTemplateStringImpl extends UriTemplateImpl implements FullUriTemplateString {
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
}
/**
 * This  type describes relative uri templates
 **/
export declare class RelativeUriStringImpl extends UriTemplateImpl implements RelativeUriString {
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
}
export declare class ResourceTypeImpl extends ResourceBaseImpl implements ResourceType {
    protected nodeOrKey: hl.IHighLevelNode | string;
    protected setAsTopLevel: boolean;
    constructor(nodeOrKey: hl.IHighLevelNode | string, setAsTopLevel?: boolean);
    /**
     * Name of the resource type
     **/
    name(): string;
    /**
     * @hidden
     * Set name value
     **/
    setName(param: string): this;
    /**
     * Instructions on how and when the resource type should be used.
     **/
    usage(): string;
    /**
     * @hidden
     * Set usage value
     **/
    setUsage(param: string): this;
    /**
     * You may import library locally here it contents is accessible only inside of this resource type
     **/
    uses(): Library[];
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
    parametrizedProperties(): TypeInstance;
}
/**
 * Schema at this moment only two subtypes are supported (json schema and xsd)
 **/
export declare class SchemaStringImpl extends StringTypeImpl implements SchemaString {
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
}
/**
 * JSON schema
 **/
export declare class JSonSchemaStringImpl extends SchemaStringImpl implements JSonSchemaString {
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
}
/**
 * XSD schema
 **/
export declare class XMLSchemaStringImpl extends SchemaStringImpl implements XMLSchemaString {
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
}
/**
 * Examples at this moment only two subtypes are supported (json  and xml)
 **/
export declare class ExampleStringImpl extends StringTypeImpl implements ExampleString {
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
}
/**
 * This sub type of the string represents mime types
 **/
export declare class MimeTypeImpl extends StringTypeImpl implements MimeType {
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
}
/**
 * [GitHub Flavored Markdown](https://help.github.com/articles/github-flavored-markdown/)
 **/
export declare class MarkdownStringImpl extends StringTypeImpl implements MarkdownString {
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
}
export declare class DocumentationItemImpl extends RAMLLanguageElementImpl implements DocumentationItem {
    protected nodeOrKey: hl.IHighLevelNode | string;
    protected setAsTopLevel: boolean;
    constructor(nodeOrKey: hl.IHighLevelNode | string, setAsTopLevel?: boolean);
    /**
     * Title of documentation section
     **/
    title(): string;
    /**
     * @hidden
     * Set title value
     **/
    setTitle(param: string): this;
    /**
     * Content of documentation section
     **/
    content(): MarkdownString;
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
}
export declare class RAMLSimpleElementImpl extends core.BasicNodeImpl implements RAMLSimpleElement {
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
}
export declare class ImportDeclarationImpl extends RAMLSimpleElementImpl implements ImportDeclaration {
    protected nodeOrKey: hl.IHighLevelNode | string;
    protected setAsTopLevel: boolean;
    constructor(nodeOrKey: hl.IHighLevelNode | string, setAsTopLevel?: boolean);
    /**
     * Name prefix (without dot) used to refer imported declarations
     **/
    key(): string;
    /**
     * @hidden
     * Set key value
     **/
    setKey(param: string): this;
    /**
     * Content of the declared namespace
     **/
    value(): Library;
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
}
/**
 * Content of the schema
 **/
export declare class GlobalSchemaImpl extends RAMLSimpleElementImpl implements GlobalSchema {
    protected nodeOrKey: hl.IHighLevelNode | string;
    protected setAsTopLevel: boolean;
    constructor(nodeOrKey: hl.IHighLevelNode | string, setAsTopLevel?: boolean);
    /**
     * Name of the global schema, used to refer on schema content
     **/
    key(): string;
    /**
     * @hidden
     * Set key value
     **/
    setKey(param: string): this;
    /**
     * Content of the schema
     **/
    value(): SchemaString;
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
}
export declare class ApiImpl extends LibraryBaseImpl implements Api {
    protected nodeOrKey: hl.IHighLevelNode | string;
    protected setAsTopLevel: boolean;
    constructor(nodeOrKey: hl.IHighLevelNode | string, setAsTopLevel?: boolean);
    /**
     * Short plain-text label for the API
     **/
    title(): string;
    /**
     * @hidden
     * Set title value
     **/
    setTitle(param: string): this;
    /**
     * The version of the API, e.g. 'v1'
     **/
    version(): string;
    /**
     * @hidden
     * Set version value
     **/
    setVersion(param: string): this;
    /**
     * A URI that's to be used as the base of all the resources' URIs. Often used as the base of the URL of each resource, containing the location of the API. Can be a template URI.
     **/
    baseUri(): FullUriTemplateString;
    /**
     * Named parameters used in the baseUri (template)
     * @hidden
     **/
    baseUriParameters_original(): TypeDeclaration[];
    /**
     * The protocols supported by the API
     **/
    protocols(): string[];
    /**
     * @hidden
     * Set protocols value
     **/
    setProtocols(param: string): this;
    /**
     * The default media type to use for request and response bodies (payloads), e.g. "application/json"
     **/
    mediaType(): MimeType;
    /**
     * The security schemes that apply to every resource and method in the API
     **/
    securedBy(): SecuritySchemeRef[];
    /**
     * The resources of the API, identified as relative URIs that begin with a slash (/). Every property whose key begins with a slash (/), and is either at the root of the API definition or is the child property of a resource property, is a resource property, e.g.: /users, /{groupId}, etc
     **/
    resources(): Resource[];
    /**
     * Additional overall documentation for the API
     **/
    documentation(): DocumentationItem[];
    /**
     * The displayName attribute specifies the $self's display name. It is a friendly name used only for  display or documentation purposes. If displayName is not specified, it defaults to the element's key (the name of the property itself).
     **/
    displayName(): string;
    /**
     * @hidden
     * Set displayName value
     **/
    setDisplayName(param: string): this;
    /**
     * A longer, human-friendly description of the API
     **/
    description(): MarkdownString;
    /**
     * Most of RAML model elements may have attached annotations decribing additional meta data about this element
     **/
    annotations(): AnnotationRef[];
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     * @hidden
     **/
    RAMLVersion_original(): string;
    /**
     * Equivalent API with traits and resource types expanded
     **/
    expand(): Api;
    /**
     * Get child resource by its relative path
     **/
    childResource(relPath: string): Resource;
    /**
     * Retrieve all resources of the Api
     **/
    allResources(): Resource[];
    /**
     * Named parameters used in the baseUri (template)
     **/
    baseUriParameters(): TypeDeclaration[];
    /**
     * Retrieve an ordered list of all base uri parameters regardless of whether they are described in `baseUriParameters` or not
     * Consider a fragment of RAML specification:
     * ```yaml
     * version: v1
     * baseUri: https://{organization}.example.com/{version}/{service}
     * baseUriParameters:
     * service:
     * ```
     * Here `version` and `organization` are base uri parameters which are not described in the `baseUriParameters` node,
     * but they are among `Api.allBaseUriParameters()`.
     * @deprecated
     **/
    allBaseUriParameters(): TypeDeclaration[];
    /**
     * Protocols used by the API. Returns the `protocols` property value if it is specified.
     * Otherwise, returns protocol, specified in the base URI.
     * @deprecated
     **/
    allProtocols(): string[];
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
}
export declare class OverlayImpl extends ApiImpl implements Overlay {
    protected nodeOrKey: hl.IHighLevelNode | string;
    protected setAsTopLevel: boolean;
    constructor(nodeOrKey: hl.IHighLevelNode | string, setAsTopLevel?: boolean);
    /**
     * contains description of why overlay exist
     **/
    usage(): string;
    /**
     * @hidden
     * Set usage value
     **/
    setUsage(param: string): this;
    /**
     * Location of a valid RAML API definition (or overlay or extension), the overlay is applied to.
     **/
    masterRef(): string;
    /**
     * @hidden
     * Set masterRef value
     **/
    setMasterRef(param: string): this;
    /**
     * Short plain-text label for the API
     **/
    title(): string;
    /**
     * @hidden
     * Set title value
     **/
    setTitle(param: string): this;
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
}
export declare class ExtensionImpl extends ApiImpl implements Extension {
    protected nodeOrKey: hl.IHighLevelNode | string;
    protected setAsTopLevel: boolean;
    constructor(nodeOrKey: hl.IHighLevelNode | string, setAsTopLevel?: boolean);
    /**
     * contains description of why extension exist
     **/
    usage(): string;
    /**
     * @hidden
     * Set usage value
     **/
    setUsage(param: string): this;
    /**
     * Location of a valid RAML API definition (or overlay or extension), the extension is applied to
     **/
    masterRef(): string;
    /**
     * @hidden
     * Set masterRef value
     **/
    setMasterRef(param: string): this;
    /**
     * Short plain-text label for the API
     **/
    title(): string;
    /**
     * @hidden
     * Set title value
     **/
    setTitle(param: string): this;
    /**
     * @hidden
     * @return Actual name of instance class
     **/
    wrapperClassName(): string;
    /**
     * @return Actual name of instance interface
     **/
    kind(): string;
    /**
     * @return RAML version of the node
     **/
    RAMLVersion(): string;
}
/**
 * Load API synchronously. If the 'rejectOnErrors' option is set to true, [[ApiLoadingError]] is thrown for Api which contains errors.
 * @param apiPath Path to API: local file system path or Web URL
 * @param options Load options
 * @return Api instance.
 **/
export declare function loadApiSync(apiPath: string, options?: coreApi.Options): Api;
/**
 * Load API synchronously. If the 'rejectOnErrors' option is set to true, [[ApiLoadingError]] is thrown for Api which contains errors.
 * @param apiPath Path to API: local file system path or Web URL
 * @param options Load options
 * @param extensionsAndOverlays Paths to extensions and overlays to be applied listed in the order of application. Relevant for RAML 1.0 only.
 * @return Api instance.
 **/
export declare function loadApiSync(apiPath: string, extensionsAndOverlays: string[], options?: coreApi.Options): Api;
/**
 * Load RAML synchronously. May load both Api and Typed fragments. If the 'rejectOnErrors' option is set to true, [[ApiLoadingError]] is thrown for RAML which contains errors.
 * @param ramlPath Path to RAML: local file system path or Web URL
 * @param options Load options
 * @param extensionsAndOverlays Paths to extensions and overlays to be applied listed in the order of application. Relevant for RAML 1.0 only.
 * @return RAMLLanguageElement instance.
 **/
export declare function loadRAMLSync(ramlPath: string, extensionsAndOverlays: string[], options?: coreApi.Options): RAMLLanguageElement;
/**
 * Load API asynchronously. The Promise is rejected with [[ApiLoadingError]] if the resulting Api contains errors and the 'rejectOnErrors' option is set to 'true'.
 * @param apiPath Path to API: local file system path or Web URL
 * @param options Load options
 * @return Promise&lt;Api&gt;.
 **/
export declare function loadApi(apiPath: string, options?: coreApi.Options): Promise<Api>;
/**
 * Load API asynchronously. The Promise is rejected with [[ApiLoadingError]] if the resulting Api contains errors and the 'rejectOnErrors' option is set to 'true'.
 * @param apiPath Path to API: local file system path or Web URL
 * @param options Load options
 * @param extensionsAndOverlays Paths to extensions and overlays to be applied listed in the order of application. Relevant for RAML 1.0 only.
 * @return Promise&lt;Api&gt;.
 **/
export declare function loadApi(apiPath: string, extensionsAndOverlays: string[], options?: coreApi.Options): Promise<Api>;
/**
 * Load RAML asynchronously. May load both Api and Typed fragments. The Promise is rejected with [[ApiLoadingError]] if the resulting RAMLLanguageElement contains errors and the 'rejectOnErrors' option is set to 'true'.
 * @param ramlPath Path to RAML: local file system path or Web URL
 * @param options Load options
 * @param extensionsAndOverlays Paths to extensions and overlays to be applied listed in the order of application. Relevant for RAML 1.0 only.
 * @return Promise&lt;RAMLLanguageElement&gt;.
 **/
export declare function loadRAML(ramlPath: string, extensionsAndOverlays: string[], options?: coreApi.Options): Promise<RAMLLanguageElement>;
/**
 * Gets AST node by runtime type, if runtime type matches any.
 * @param runtimeType - runtime type to find the match for
 */
export declare function getLanguageElementByRuntimeType(runtimeType: hl.ITypeDefinition): core.BasicNode;
