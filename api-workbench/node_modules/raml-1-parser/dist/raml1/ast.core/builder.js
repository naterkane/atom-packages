/// <reference path="../../../typings/main.d.ts" />
"use strict";
var defs = require("raml-definition-system");
var yaml = require("yaml-ast-parser");
var _ = require("underscore");
var def = defs;
var hlimpl = require("../highLevelImpl");
var proxy = require("./LowLevelASTProxy");
var search = require("./search");
var universes = require("../tools/universe");
var universeHelpers = require("../tools/universeHelpers");
var services = defs;
var KeyMatcher = (function () {
    function KeyMatcher(_props) {
        this._props = _props;
        this.parentValue = _.find(_props, function (x) { return x.isFromParentValue(); });
        this.parentKey = _.find(_props, function (x) { return x.isFromParentKey(); });
        this.canBeValue = _.find(_props, function (x) { return x.canBeValue(); });
    }
    KeyMatcher.prototype.match = function (key) {
        var _this = this;
        var _res = null;
        var lastPref = "";
        this._props.forEach(function (p) {
            if (p.getAdapter(services.RAMLPropertyService).isSystem()) {
                return;
            }
            if (p != _this.parentValue && p != _this.parentKey && p.matchKey(key)) {
                if (p.keyPrefix() != null) {
                    if (p.keyPrefix().length >= lastPref.length) {
                        lastPref = p.keyPrefix();
                        _res = p;
                    }
                }
                else {
                    _res = p;
                    lastPref = p.nameId();
                }
            }
        });
        return _res;
    };
    return KeyMatcher;
}());
function getAllOptions(c, deep) {
    if (deep === void 0) { deep = 0; }
    if (deep > 20) {
        return [];
    }
    try {
        var result = [];
        var tp = c.leftType();
        if (tp) {
            result.push(tp);
        }
        var r = c.rightType();
        if (r) {
            if (r.hasUnionInHierarchy()) {
                var options = getAllOptions(r.unionInHierarchy(), deep + 1);
                result = result.concat(options);
            }
            else {
                result.push(r);
            }
        }
        return result;
    }
    finally {
    }
}
var ad = 0;
var BasicNodeBuilder = (function () {
    function BasicNodeBuilder() {
        this.shouldDescriminate = false;
    }
    BasicNodeBuilder.prototype.process = function (node, childrenToAdopt) {
        var _this = this;
        var nn = node.lowLevel();
        var cha = nn._node ? nn._node : nn;
        try {
            if (cha['currentChildren']) {
                return cha['currentChildren'];
            }
            if (!node.definition()) {
                return;
            }
            if (node.parent() == null && (!this.shouldDescriminate)) {
                this.shouldDescriminate = true;
                try {
                    var children = this.process(node, childrenToAdopt);
                    var ts = node;
                    ts._children = children;
                    var t = doDescrimination(node);
                    if (t) {
                        ts.patchType(t);
                    }
                    var children = this.process(node, childrenToAdopt);
                    ts._children = children;
                }
                finally {
                    this.shouldDescriminate = false;
                }
            }
            if (node.definition().hasUnionInHierarchy()) {
                if (true &&
                    (node.parent() && node.property().nameId() == universes.Universe10.RAMLLanguageElement.properties.annotations.name)) {
                    var optins = getAllOptions(node.definition().unionInHierarchy());
                    var actualResult = null;
                    var bestResult = null;
                    var bestType = null;
                    var bestCount = 1000;
                    var llnode = node;
                    optins.forEach(function (x) {
                        if (!actualResult) {
                            //TODO ADD UNION + Descriminator
                            if (!(x).hasUnionInHierarchy()) {
                                var tp = llnode.patchType(x);
                                if (ad == 0) {
                                    ad++;
                                    try {
                                        var result = _this.process(node, childrenToAdopt);
                                        var uc = 0;
                                        for (var i = 0; i < result.length; i++) {
                                            if (result[i].isUnknown()) {
                                                uc++;
                                            }
                                        }
                                        if (uc == 0) {
                                            actualResult = result;
                                        }
                                        if (bestCount > uc) {
                                            bestCount = uc;
                                            bestResult = result;
                                            bestType = x;
                                        }
                                    }
                                    finally {
                                        ad--;
                                    }
                                }
                            }
                        }
                    });
                    if (actualResult) {
                        llnode.patchType(bestType);
                        return actualResult;
                    }
                    if (bestResult) {
                        llnode.patchType(bestType);
                    }
                }
            }
            var km = new KeyMatcher(node.definition().allProperties());
            var aNode = node;
            var allowsQuestion = aNode._allowQuestion || node.definition().getAdapter(services.RAMLService).getAllowQuestion();
            var res = [];
            //cha['currentChildren']=res;
            if (km.parentKey) {
                if (node.lowLevel().key()) {
                    var keyAttr = new hlimpl.ASTPropImpl(node.lowLevel(), node, km.parentKey.range(), km.parentKey, true);
                    res.push(keyAttr);
                    var isDefaultMediaType = node.property()
                        && universeHelpers.isBodyProperty(node.property())
                        && node.lowLevel().key() == node.property().nameId();
                    if (isDefaultMediaType) {
                        var isInsideTraitOrResourceType = isInTtraitOrResourceType(aNode);
                        if (!isInsideTraitOrResourceType) {
                            var vl = aNode.computedValue(universes.Universe10.Api.properties.mediaType.name);
                            keyAttr.overrideValue(vl);
                        }
                    }
                }
            }
            if (node.lowLevel().value()) {
                if (km.parentValue) {
                    res.push(new hlimpl.ASTPropImpl(node.lowLevel(), node, km.parentValue.range(), km.parentValue));
                }
                else if (km.canBeValue) {
                    var s = node.lowLevel().value();
                    if (typeof s == 'string' && s.trim().length > 0) {
                        //if (km.canBeValue.nameId()==universes.Universe10.Resource.properties.signature.name){
                        //      if (s.trim().charAt(0)=='('){
                        //          //TODO BETTER DECITION current one prevents completion from working correctly
                        //          //in few other cases
                        //          res.push(new hlimpl.ASTPropImpl(node.lowLevel(), node, km.canBeValue.range(), km.canBeValue));
                        //      }
                        //}
                        //else {
                        res.push(new hlimpl.ASTPropImpl(node.lowLevel(), node, km.canBeValue.range(), km.canBeValue));
                    }
                    else if (node.definition().isAssignableFrom(universes.Universe10.Annotation.name) &&
                        node.definition().property("value")) {
                        //"value" is a magic property name we do not have reflected in serialized def. system, so have to use plain string
                        var lowLevelNode = node.lowLevel();
                        var valueAttribute = _.find(lowLevelNode.children(), function (child) {
                            return child.kind() == yaml.Kind.MAPPING && child.key() && child.key() == "value";
                        });
                        if (!valueAttribute) {
                            //annotation reference is not a scalar and does not have value attribute, but has value defined in the annotation declaration
                            //that means user wants to use a shortcut and specify value object directly under annotation
                            var valueProperty = node.definition().property("value");
                            //creating "value" high-level node referencing the same low-level node so the children can be collected
                            var valueNode = new hlimpl.ASTNodeImpl(node.lowLevel(), node, valueProperty.range(), valueProperty);
                            return [valueNode];
                        }
                    }
                }
            }
            else {
                if (km.canBeValue && (km.canBeValue.range() instanceof def.NodeClass || (km.canBeValue.range().hasUnionInHierarchy() && node.definition().isAssignableFrom(universes.Universe10.Annotation.name)))) {
                    //check check for annotation is just for safety, generally, imho, we should go inside for any unions
                    var ch = new hlimpl.ASTNodeImpl(node.lowLevel(), aNode, km.canBeValue.range(), km.canBeValue);
                    return [ch];
                }
            }
            aNode._children = res;
            if (!aNode.definition().getAdapter(services.RAMLService).isUserDefined()) {
                if (aNode.definition().key() == universes.Universe08.Api || aNode.definition().key() == universes.Universe10.Api) {
                    var uses = childrenToAdopt.filter(function (x) { return x.key() == "uses"; });
                    res = this.processChildren(uses, aNode, res, allowsQuestion, km);
                    var types = childrenToAdopt.filter(function (x) { return x.key() == "types"; });
                    res = this.processChildren(types, aNode, res, allowsQuestion, km);
                    var other = childrenToAdopt.filter(function (x) { return (x.key() != "types" && x.key() != "uses"); });
                    res = this.processChildren(other, aNode, res, allowsQuestion, km);
                }
                else {
                    res = this.processChildren(childrenToAdopt, aNode, res, allowsQuestion, km);
                }
            }
            else {
                res = this.processChildren(childrenToAdopt, aNode, res, allowsQuestion, km);
            }
            aNode._children = res;
            return res;
        }
        finally {
            if (ch) {
                delete cha['currentChildren'];
            }
        }
    };
    BasicNodeBuilder.prototype.isTypeDeclarationShortcut = function (node, property) {
        var isTypeDeclarationType = universeHelpers.isTypeProperty(property);
        var isTypeDeclaration = node.definition() && universeHelpers.isTypeDeclarationTypeOrDescendant(node.definition());
        if (isTypeDeclaration && isTypeDeclarationType && node.lowLevel() && node.lowLevel().valueKind() === yaml.Kind.SEQ) {
            return true;
        }
        return false;
    };
    BasicNodeBuilder.prototype.processChildren = function (childrenToAdopt, aNode, res, allowsQuestion, km) {
        var _this = this;
        var typeDeclarationName = universes.Universe10.TypeDeclaration.name;
        var typePropertyName = universes.Universe10.TypeDeclaration.properties.type.name;
        if (aNode.definition() && aNode.definition().isAssignableFrom(typeDeclarationName) && aNode.lowLevel() && (km.canBeValue && km.canBeValue.nameId() === typePropertyName) && aNode.lowLevel()._node && aNode.lowLevel()._node.value && aNode.lowLevel()._node.value.kind === yaml.Kind.SEQ) {
            childrenToAdopt.forEach(function (child) {
                var property = new hlimpl.ASTPropImpl(child, aNode, km.canBeValue.range(), km.canBeValue);
                res.push(property);
            });
            return res;
        }
        childrenToAdopt.forEach(function (x) {
            if (km.canBeValue && _this.isTypeDeclarationShortcut(aNode, km.canBeValue)) {
                res.push(new hlimpl.ASTPropImpl(x, aNode, km.canBeValue.range(), km.canBeValue));
                return;
            }
            var key = x.key();
            //if (x.optional()&&!allowsQuestion) {
            //    return;
            //}
            var p = key != null ? km.match(key) : null;
            if (p != null) {
                var range = p.range();
                if (p.isAnnotation() && key != "annotations") {
                    var pi = new hlimpl.ASTPropImpl(x, aNode, range, p);
                    res.push(pi);
                    return;
                }
                var um = false;
                var multyValue = p.isMultiValue();
                if (range.isArray()) {
                    multyValue = true;
                    range = range.array().componentType();
                    um = true;
                }
                else if (range.hasArrayInHierarchy()) {
                    multyValue = true;
                    um = true;
                }
                //TODO DESCRIMINATORS
                if (range.hasValueTypeInHierarchy()) {
                    var ch = x.children();
                    var seq = (x.valueKind() == yaml.Kind.SEQ);
                    if ((seq && ch.length > 0 || ch.length > 1) && multyValue) {
                        ch.forEach(function (y) {
                            var pi = new hlimpl.ASTPropImpl(y, aNode, range, p);
                            res.push(pi);
                        });
                    }
                    else {
                        if (p.isInherited()) {
                            aNode.setComputed(p.nameId(), x.value());
                        }
                        var attrNode = new hlimpl.ASTPropImpl(x, aNode, range, p);
                        if ((seq || x.valueKind() == yaml.Kind.MAP)) {
                            var rng = p.range().nameId();
                            if (!p.getAdapter(services.RAMLPropertyService).isExampleProperty()) {
                                if (rng == 'StringType') {
                                    rng = "string";
                                }
                                if (rng == 'NumberType') {
                                    rng = "number";
                                }
                                if (rng == 'BooleanType') {
                                    rng = "boolean";
                                }
                                if (rng == "string" || rng == "number" || rng == "boolean") {
                                    attrNode.errorMessage = "property '" + p.groupName() + "' must be a " + rng;
                                    if (x.children().length == 0 && p.groupName() == "enum") {
                                        attrNode.errorMessage = "enum is empty";
                                        if (x.valueKind() == yaml.Kind.MAP) {
                                            attrNode.errorMessage = "the value of enum must be an array";
                                        }
                                    }
                                }
                            }
                        }
                        res.push(attrNode);
                    }
                    //}
                    return;
                }
                else {
                    var rs = [];
                    //now we need determine actual type
                    aNode._children = res;
                    if (x.value() != null && (typeof x.value() == 'string' || typeof x.value() == 'boolean' || typeof x.value() == 'number')) {
                        if (("" + x.value()).trim().length > 0) {
                            var c = p.range();
                            if (!c.allProperties().some(function (x) {
                                var srv = x;
                                if (srv) {
                                    return srv.canBeValue() && srv.isFromParentValue();
                                }
                                return false;
                            })) {
                                var bnode = new hlimpl.BasicASTNode(x, aNode);
                                bnode.getLowLevelEnd = function () {
                                    return -1;
                                };
                                bnode.getLowLevelStart = function () {
                                    return -1;
                                };
                                bnode.knownProperty = p;
                                res.push(bnode);
                            }
                        }
                    }
                    if (!p.isMerged()) {
                        if (multyValue) {
                            if (p.getAdapter(services.RAMLPropertyService).isEmbedMap()) {
                                var chld = x.children();
                                if (chld.length == 0) {
                                    if (p.range().key() == universes.Universe08.ResourceType) {
                                        var error = new hlimpl.BasicASTNode(x, aNode);
                                        error.errorMessage = "property: '" + p.nameId() + "' must be a map";
                                        res.push(error);
                                    }
                                    if (x.valueKind() == yaml.Kind.SCALAR) {
                                        if (p.range().key() == universes.Universe08.AbstractSecurityScheme) {
                                            var error = new hlimpl.BasicASTNode(x, aNode);
                                            error.errorMessage = "property: '" + p.nameId() + "' must be a map";
                                            res.push(error);
                                        }
                                    }
                                }
                                chld.forEach(function (y) {
                                    //TODO TRACK GROUP KEY
                                    var cld = y.children();
                                    if (!y.key() && cld.length == 1) {
                                        var node = new hlimpl.ASTNodeImpl(cld[0], aNode, range, p);
                                        node._allowQuestion = allowsQuestion;
                                        rs.push(node);
                                    }
                                    else {
                                        if (aNode.universe().version() == "RAML10") {
                                            var node = new hlimpl.ASTNodeImpl(y, aNode, range, p);
                                            node._allowQuestion = allowsQuestion;
                                            rs.push(node);
                                        }
                                        else {
                                            var bnode = new hlimpl.BasicASTNode(y, aNode);
                                            res.push(bnode);
                                            if (y.key()) {
                                                bnode.needSequence = true;
                                            }
                                        }
                                    }
                                });
                            }
                            else {
                                var filter = {};
                                var inherited = [];
                                if (range instanceof defs.NodeClass) {
                                    var nc = range;
                                    if (nc.getAdapter(services.RAMLService).getCanInherit().length > 0) {
                                        nc.getAdapter(services.RAMLService).getCanInherit().forEach(function (v) {
                                            var vl = aNode.computedValue(v);
                                            if (vl && p.nameId() == universes.Universe10.Response.properties.body.name) {
                                                if (!_.find(x.children(), function (x) { return x.key() == vl; })) {
                                                    //we can create inherited node;
                                                    var pc = aNode.parent().definition().key();
                                                    var node = new hlimpl.ASTNodeImpl(x, aNode, range, p);
                                                    if (pc == universes.Universe10.MethodBase || pc == universes.Universe08.MethodBase) {
                                                        node.setComputed("form", "true"); //FIXME
                                                    }
                                                    var isInsideTraitOrResourceType = isInTtraitOrResourceType(aNode);
                                                    var t = descriminate(p, aNode, node);
                                                    if (t) {
                                                        if (!isInsideTraitOrResourceType) {
                                                            t.setName(vl);
                                                        }
                                                        node.patchType(t);
                                                    }
                                                    var ch = node.children();
                                                    //this are false unknowns actual unknowns will be reported by parent node
                                                    node._children = ch.filter(function (x) { return !x.isUnknown(); });
                                                    node._allowQuestion = allowsQuestion;
                                                    inherited.push(node);
                                                    node.children().forEach(function (x) {
                                                        if (x.property().getAdapter(services.RAMLPropertyService).isKey()) {
                                                            var atr = x;
                                                            atr._computed = true;
                                                            return;
                                                        }
                                                        if (x.isElement()) {
                                                            if (!x.property().getAdapter(services.RAMLPropertyService).isMerged()) {
                                                                filter[x.property().nameId()] = true;
                                                            }
                                                        }
                                                        if (x.property().isAnnotation()) {
                                                            var atr = x;
                                                            var vl = atr.value();
                                                            var strVal = "";
                                                            if (vl instanceof hlimpl.StructuredValue) {
                                                                strVal = vl.valueName();
                                                            }
                                                            else {
                                                                strVal = "" + vl;
                                                            }
                                                            filter["(" + strVal + ")"] = true;
                                                        }
                                                        else {
                                                            filter[x.name()] = true;
                                                        }
                                                    });
                                                    var ap = node.definition().allProperties();
                                                    ap.forEach(function (p) {
                                                        if (p.getAdapter(services.RAMLPropertyService).isKey()) {
                                                            return;
                                                        }
                                                        if (p.getAdapter(services.RAMLPropertyService).isSystem()) {
                                                            return;
                                                        }
                                                        if (node.lowLevel().children().some(function (x) { return x.key() == p.nameId(); })) {
                                                            filter[p.nameId()] = true;
                                                        }
                                                    });
                                                    node._computed = true;
                                                }
                                            }
                                        });
                                    }
                                }
                                var parsed = [];
                                if (x.children().length == 0) {
                                    if (x.valueKind() == yaml.Kind.SEQ) {
                                        if (p.range().key() == universes.Universe08.Parameter) {
                                            var error = new hlimpl.BasicASTNode(x, aNode);
                                            error.errorMessage = "property: '" + p.nameId() + "' must be a map";
                                            res.push(error);
                                        }
                                    }
                                }
                                x.children().forEach(function (y) {
                                    if (filter[y.key()]) {
                                        return;
                                    }
                                    if (y.valueKind() == yaml.Kind.SEQ) {
                                        y.children().forEach(function (z) {
                                            var node = new hlimpl.ASTNodeImpl(z, aNode, range, p);
                                            node._allowQuestion = allowsQuestion;
                                            node.setNamePatch(y.key());
                                            parsed.push(node);
                                        });
                                        if (y.children().length == 0) {
                                            var error = new hlimpl.BasicASTNode(y, aNode);
                                            if (p.range().key() == universes.Universe08.Parameter) {
                                                error.errorMessage = "named parameter needs at least one type";
                                            }
                                            else {
                                                error.errorMessage = "node should have at least one member value";
                                            }
                                            res.push(error);
                                        }
                                    }
                                    else {
                                        var node = new hlimpl.ASTNodeImpl(y, aNode, range, p);
                                        var dc = p.domain().key();
                                        if (p.nameId() == "body" && (dc == universes.Universe08.MethodBase || dc == universes.Universe10.MethodBase)) {
                                            node.setComputed("form", "true"); //FIXME
                                        }
                                        node._allowQuestion = allowsQuestion;
                                        parsed.push(node);
                                    }
                                });
                                if (parsed.length > 0) {
                                    parsed.forEach(function (x) { return rs.push(x); });
                                }
                                else {
                                    inherited.forEach(function (x) { return rs.push(x); });
                                }
                            }
                        }
                        else {
                            //var y=x.children()[0];
                            rs.push(new hlimpl.ASTNodeImpl(x, aNode, range, p));
                        }
                    }
                    else {
                        var node = new hlimpl.ASTNodeImpl(x, aNode, range, p);
                        node._allowQuestion = allowsQuestion;
                        rs.push(node);
                    }
                    aNode._children = aNode._children.concat(rs);
                    res = res.concat(rs);
                    rs.forEach(function (x) {
                        var rt = descriminate(p, aNode, x);
                        if (rt && rt != x.definition()) {
                            x.patchType(rt);
                        }
                        x._associatedDef = null;
                        p.childRestrictions().forEach(function (y) {
                            x.setComputed(y.name, y.value);
                        });
                        var def = x.definition();
                    });
                }
            }
            else {
                if (!(x instanceof proxy.LowLevelCompositeNode)
                    || x.primaryNode() != null) {
                    res.push(new hlimpl.BasicASTNode(x, aNode));
                }
            }
        });
        return res;
    };
    return BasicNodeBuilder;
}());
exports.BasicNodeBuilder = BasicNodeBuilder;
function getType(node, expression) {
    if (!expression) {
        return node.definition().universe().type("StringTypeDeclaration");
    }
    var pt = node.parsedType();
    if (pt.isString()) {
        return (node.definition().universe().type("StringTypeDeclaration"));
    }
    if (pt.isNumber()) {
        return (node.definition().universe().type("NumberTypeDeclaration"));
    }
    if (pt.isObject()) {
        return (node.definition().universe().type("ObjectTypeDeclaration"));
    }
    if (pt.isArray()) {
        return (node.definition().universe().type("ArrayTypeDeclaration"));
    }
    if (pt.isFile()) {
        return (node.definition().universe().type("FileTypeDeclaration"));
    }
    return (node.definition().universe().type("TypeDeclaration"));
}
function desc1(p, parent, x) {
    var tp = x.attr("type");
    var value = "";
    if (tp) {
        var mn = {};
        var c = new def.NodeClass(x.name(), x.definition().universe(), "");
        c.getAdapter(services.RAMLService).setDeclaringNode(x);
        c._superTypes.push(x.definition().universe().type(universes.Universe10.TypeDeclaration.name));
        mn[tp.value()] = c;
        var newType = getType(x, tp.value());
        if (newType) {
            if (newType.superTypes().length == 0) {
                newType._superTypes.push(x.definition().universe().type(universes.Universe10.TypeDeclaration.name));
            }
        }
        return newType;
    }
    else {
        var propertiesName = universes.Universe10.ObjectTypeDeclaration.properties.properties.name;
        if (p) {
            if (p.nameId() == "body" || _.find(x.lowLevel().children(), function (x) { return x.key() === propertiesName; })) {
                return x.definition().universe().type(universes.Universe10.ObjectTypeDeclaration.name);
            }
        }
        else {
            if (!parent && x.lowLevel() && _.find(x.lowLevel().children(), function (x) { return x.key() === propertiesName; })) {
                return x.definition().universe().type(universes.Universe10.ObjectTypeDeclaration.name);
            }
        }
        return x.definition().universe().type(universes.Universe10.StringTypeDeclaration.name);
    }
}
function doDescrimination(node) {
    try {
        var nodeDefenitionName = node.definition().nameId();
        var isApi = nodeDefenitionName === universes.Universe10.Api.name || nodeDefenitionName === universes.Universe08.Api.name;
        if (!isApi && !node.property() && !node.parent() && node.definition().nameId() === hlimpl.getFragmentDefenitionName(node)) {
            if (node.definition().isAssignableFrom(universes.Universe10.AnnotationTypeDeclaration.name)) {
                return descriminate(null, null, node);
            }
            var result = null;
            var subTypes = node.definition().allSubTypes();
            subTypes.forEach(function (subType) {
                if (!result && match(subType, node, null)) {
                    result = subType;
                }
            });
            return result;
        }
    }
    catch (exception) {
    }
    return descriminate(node.property(), node.parent(), node);
}
exports.doDescrimination = doDescrimination;
function descriminate(p, parent, x) {
    var n = x.lowLevel();
    if (p) {
        if (p.nameId() == universes.Universe10.LibraryBase.properties.uses.name &&
            p.range().nameId() == universes.Universe10.Library.name) {
        }
    }
    var range = p ? p.range().nameId() : x.definition().nameId();
    if (n._node && n._node['descriminate']) {
        return null;
    }
    if (n._node) {
        n._node['descriminate'] = 1;
    }
    try {
        if (range == universes.Universe10.TypeDeclaration.name
            || range == universes.Universe10.AnnotationTypeDeclaration.name) {
            var res = desc1(p, parent, x);
            if (p || (!p && !parent && x.lowLevel())) {
                if (p && res != null && ((p.nameId() == universes.Universe10.MethodBase.properties.body.name
                    || p.nameId() == universes.Universe10.Response.properties.headers.name) ||
                    p.nameId() == universes.Universe10.Method.properties.queryParameters.name)) {
                    var ares = new defs.UserDefinedClass(x.lowLevel().key(), res.universe(), x, x.lowLevel().unit() ? x.lowLevel().unit().path() : "", "");
                    ares._superTypes.push(res);
                    return ares;
                }
                if (res != null && universeHelpers.isAnnotationTypeType(x.definition())) {
                    var annotationType = descriminateAnnotationType(res);
                    var ares = new defs.UserDefinedClass(x.lowLevel().key(), res.universe(), x, x.lowLevel().unit() ? x.lowLevel().unit().path() : "", "");
                    ares._superTypes.push(annotationType);
                    ares._superTypes.push(res);
                    return ares;
                }
            }
            if (res) {
                return res;
            }
        }
        //generic case;
        var rt = null;
        if (p && parent) {
            var types = search.findAllSubTypes(p, parent);
            if (types.length > 0) {
                types.forEach(function (y) {
                    if (!rt) {
                        if (match(y, x, rt)) {
                            rt = y;
                        }
                    }
                });
            }
            return rt;
        }
    }
    finally {
        if (n._node) {
            delete n._node['descriminate'];
        }
    }
}
;
function descriminateAnnotationType(type) {
    var arr = [type].concat(type.allSuperTypes());
    var candidate;
    for (var i = 0; i < arr.length; i++) {
        var t = arr[i];
        if (t.isUserDefined()) {
            continue;
        }
        if (t.isUnion()) {
            var ut = t;
            var lt = ut.leftType();
            var rt = ut.leftType();
            var lat = descriminateAnnotationType(lt);
            var rat = descriminateAnnotationType(lt);
            if (lat.isAssignableFrom(rat.nameId()) && (candidate == null || lat.isAssignableFrom(candidate.nameId()))) {
                candidate = lat;
                continue;
            }
            if (rat.isAssignableFrom(lat.nameId()) && (candidate == null || rat.isAssignableFrom(candidate.nameId()))) {
                candidate = rat;
                continue;
            }
            candidate = type.universe().type(universes.Universe10.UnionAnnotationTypeDeclaration.name);
            break;
        }
        if (t.isArray()) {
            candidate = type.universe().type(universes.Universe10.ArrayAnnotationTypeDeclaration.name);
            break;
        }
        var subTypes = t.subTypes();
        for (var j = 0; j < subTypes.length; j++) {
            var st = subTypes[j];
            if (st.isAssignableFrom(universes.Universe10.AnnotationTypeDeclaration.name)) {
                if (candidate == null) {
                    candidate = st;
                }
                else if (st.isAssignableFrom(candidate.nameId())) {
                    candidate = st;
                }
            }
        }
    }
    return candidate != null ? candidate : type.universe().type(universes.Universe10.AnnotationTypeDeclaration.name);
}
var isInTtraitOrResourceType = function (aNode) {
    var isInsideTraitOrResourceType = false;
    var parent_ = aNode;
    while (parent_) {
        var pDef = parent_.definition();
        if (universeHelpers.isTraitType(pDef)
            || universeHelpers.isResourceTypeType(pDef)) {
            isInsideTraitOrResourceType = true;
            break;
        }
        parent_ = parent_.parent();
    }
    return isInsideTraitOrResourceType;
};
function match(t, r, alreadyFound) {
    //this.vReqInitied=true;
    if (r.isAttr() || r.isUnknown()) {
        return false;
    }
    var el = r;
    var hasSuperType = _.find(t.superTypes(), function (x) {
        var dp = _.find(x.allProperties(), function (x) { return (x).isDescriminator(); });
        if (dp) {
            var a = el.attr(dp.nameId());
            if (a) {
                if (a.value() == t.nameId()) {
                    return true;
                }
            }
        }
        return false;
    });
    if (hasSuperType) {
        return true;
    }
    if (t.valueRequirements().length == 0) {
        return false;
    }
    var matches = true;
    //descriminating constraint
    t.valueRequirements().forEach(function (x) {
        var a = el.attr(x.name);
        if (a) {
            if (a.value() == x.value) {
            }
            else {
                if (t.getAdapter(services.RAMLService).getConsumesRefs()) {
                    var vl = a.value();
                    var allSubs = [];
                    t.superTypes().forEach(function (x) { return x.allSubTypes().forEach(function (y) {
                        allSubs.push(y);
                    }); });
                    var allSubNames = [];
                    _.unique(allSubs).forEach(function (x) {
                        allSubNames.push(x.nameId());
                        x.valueRequirements().forEach(function (y) {
                            allSubNames.push(y.value);
                        });
                        x.getAdapter(services.RAMLService).getAliases().forEach(function (y) { return allSubNames.push(y); });
                    });
                    if (_.find(allSubNames, function (x) { return x == vl; })) {
                        matches = false;
                    }
                }
                else {
                    matches = false;
                }
            }
        }
        else {
            var m = t.getAdapter(services.RAMLService).getDefining();
            var ms = false;
            m.forEach(function (x) {
                el.lowLevel().children().forEach(function (y) {
                    if (y.key() == x) {
                        ms = true;
                    }
                });
            });
            if (ms) {
                matches = true;
                return;
            }
            if (!alreadyFound) {
                var pr = t.property(x.name);
                if (pr && pr.defaultValue() == x.value) {
                }
                else {
                    matches = false;
                }
            }
            else {
                matches = false;
            }
        }
    });
    return matches;
}
//# sourceMappingURL=builder.js.map