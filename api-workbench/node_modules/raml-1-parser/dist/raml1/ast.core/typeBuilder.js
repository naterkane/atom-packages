/// <reference path="../../../typings/main.d.ts" />
"use strict";
var defs = require("raml-definition-system");
var ramlTypes = defs.rt;
var _ = require("underscore");
var universes = require("../tools/universe");
var hlimpl = require("../highLevelImpl");
var services = defs;
var linter = require("./linter");
ramlTypes.setPropertyConstructor(function (x) {
    var v = new defs.Property(x);
    v.unmerge();
    return v;
});
function templateFields(node, d) {
    var u = node.root().definition().universe();
    node.children().forEach(function (x) { return templateFields(x, d); });
    if (node instanceof hlimpl.ASTPropImpl) {
        var prop = node;
        //TODO RECURSIVE PARAMETERS
        var v = prop.value();
        if (typeof v == 'string') {
            var strV = v;
            handleValue(strV, d, prop, false, u);
        }
        else {
            node.lowLevel().visit(function (x) {
                if (x.value()) {
                    var strV = x.value() + "";
                    handleValue(strV, d, prop, true, u);
                }
                return true;
            });
        }
    }
    else if (node instanceof hlimpl.BasicASTNode) {
        var v = node.lowLevel().value();
        if (typeof v == 'string') {
            var strV = v;
            handleValue(strV, d, null, false, u);
        }
        else {
            node.lowLevel().visit(function (x) {
                if (x.value()) {
                    var strV = x.value() + "";
                    handleValue(strV, d, null, true, u);
                }
                return true;
            });
        }
    }
}
var handleValue = function (strV, d, prop, allwaysString, u) {
    var ps = 0;
    while (true) {
        var pos = strV.indexOf("<<", ps);
        if (pos != -1) {
            var end = strV.indexOf(">>", pos);
            var isFull = pos == 0 && end == strV.length - 2;
            var parameterUsage = strV.substring(pos + 2, end);
            ps = pos + 2;
            var directiveIndex = parameterUsage.indexOf("|");
            if (directiveIndex != -1) {
                parameterUsage = parameterUsage.substring(0, directiveIndex);
            }
            parameterUsage = parameterUsage.trim();
            if (linter.RESERVED_TEMPLATE_PARAMETERS[parameterUsage] != null) {
                //Handling reserved parameter names;
                continue;
            }
            var q = d[parameterUsage];
            var r = (prop) ? prop.property().range() : null;
            if (prop) {
                if (prop.property().nameId() == universes.Universe10.TypeDeclaration.properties.type.name ||
                    prop.property().nameId() == universes.Universe10.TypeDeclaration.properties.schema.name) {
                    if (prop.property().domain().key() == universes.Universe10.TypeDeclaration) {
                        r = u.type(universes.Universe10.SchemaString.name);
                    }
                }
            }
            if (!isFull || allwaysString) {
                r = u.type(universes.Universe10.StringType.name);
            }
            //FIX ME NOT WHOLE TEMPLATES
            if (q) {
                q.push({
                    tp: r,
                    attr: prop
                });
            }
            else {
                d[parameterUsage] = [{
                        tp: r,
                        attr: prop
                    }];
            }
        }
        else
            break;
    }
};
function fillTemplateType(result, node) {
    var usages = {};
    templateFields(node, usages);
    result.getAdapter(services.RAMLService).setInlinedTemplates(true);
    Object.keys(usages).forEach(function (x) {
        var prop = new defs.UserDefinedProp(x);
        //prop._node=node;
        prop.withDomain(result);
        var tp = _.unique(usages[x]).map(function (x) { return x.tp; }).filter(function (x) { return x && x.nameId() != universes.Universe08.StringType.name; });
        prop.withRange(tp.length == 1 ? tp[0] : node.definition().universe().type(universes.Universe08.StringType.name));
        prop.withRequired(true);
        if (usages[x].length > 0) {
            prop._node = usages[x][0].attr;
        }
        if (tp.length == 1 && node.definition().universe().version() == 'RAML10') {
            if (tp[0].key() == universes.Universe10.SchemaString) {
                prop.getAdapter(services.RAMLPropertyService).setTypeExpression(true);
            }
        }
        prop.unmerge();
    });
    var keyProp = new defs.UserDefinedProp("____key");
    //prop._node=node;
    keyProp.withDomain(result);
    keyProp.withKey(true);
    keyProp._node = node;
    keyProp.withFromParentKey(true);
    keyProp.withRange(node.definition().universe().type(universes.Universe08.StringType.name));
    return result;
}
function fillReferenceType(result, def) {
    if (def.universe().version() == "RAML08") {
        result.getAdapter(services.RAMLService).withAllowAny();
    }
    var p = def.property(def.getAdapter(services.RAMLService).getReferenceIs());
    if (p) {
        p.range().properties().forEach(function (x) {
            var prop = new defs.Property(x.nameId());
            prop.unmerge();
            prop.withDomain(result);
            prop.withRange(x.range());
            prop.withMultiValue(x.isMultiValue());
        });
    }
    return result;
}
function typeFromNode(node) {
    if (!node) {
        return null;
    }
    if (node.associatedType()) {
        return node.associatedType();
    }
    var u = node.lowLevel().unit();
    var upath = u ? u.path() : "";
    ramlTypes.setPropertyConstructor(function (x) {
        var v = new defs.UserDefinedProp(x);
        var rs = node.elementsOfKind("properties").filter(function (y) { return y.name() == x; });
        if (rs) {
            v._node = rs[0];
        }
        v.unmerge();
        return v;
    });
    var def = node.definition();
    if (node.property() && node.property().nameId() == universes.Universe10.LibraryBase.properties.annotationTypes.name) {
        //var st=node.definition().getAdapter(services.RAMLService).toRuntime();
        var result = new defs.AnnotationType(node.name(), node.definition().universe(), node, upath, "");
        var st = getSimpleType(node);
        result._superTypes.push(st);
        if (node.elementsOfKind(universes.Universe10.ObjectTypeDeclaration.properties.properties.name).length == 0) {
            result.getAdapter(services.RAMLService).withAllowAny();
        }
        var extType = def.getAdapter(services.RAMLService).getExtendedType();
        if (extType) {
            result._superTypes.push(extType);
        }
        return result;
    }
    else {
        var result = new defs.UserDefinedClass(node.name(), node.definition().universe(), node, upath, "");
    }
    node.setAssociatedType(result);
    //result.setDeclaringNode(node);
    if (def.getAdapter(services.RAMLService).isInlinedTemplates()) {
        return fillTemplateType(result, node);
    }
    else if (def.getAdapter(services.RAMLService).getReferenceIs()) {
        return fillReferenceType(result, def);
    }
    var rs = getSimpleType(node);
    rs.getAdapter(services.RAMLService).setDeclaringNode(node);
    node.setAssociatedType(rs);
    return rs;
}
exports.typeFromNode = typeFromNode;
function getSimpleType(node) {
    return ramlTypes.toNominal(node.parsedType(), function (x) {
        var m = node.definition().universe().type(x);
        if (!m) {
            var ut = new defs.UserDefinedClass("", node.definition().universe(), node, "", "");
        }
        return m;
    });
}
function convertType(root, t) {
    var node = _.find(root.elementsOfKind("types"), function (x) { return x.name() == t.name(); });
    if (node) {
        ramlTypes.setPropertyConstructor(function (x) {
            var v = new defs.UserDefinedProp(x);
            var rs = node.elementsOfKind("properties").filter(function (y) { return y.name() == x; });
            if (rs && rs.length > 0) {
                v._node = rs[0];
            }
            else {
                var rs = node.elementsOfKind("facets").filter(function (y) { return y.name() == x; });
                if (rs && rs.length > 0) {
                    v._node = rs[0];
                }
            }
            v.unmerge();
            return v;
        });
    }
    return ramlTypes.toNominal(t, function (x) {
        var m = root.definition().universe().type(x);
        if (!m) {
            var ut = new defs.UserDefinedClass("", root.definition().universe(), root, "", "");
        }
        return m;
    });
}
exports.convertType = convertType;
//# sourceMappingURL=typeBuilder.js.map